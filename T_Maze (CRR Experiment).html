<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRR Framework ‚Äî T-Maze: Coherence-Rupture-Regeneration</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;1,400&family=JetBrains+Mono:wght@300;400&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #0d1825;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            font-family: 'Cormorant Garamond', Georgia, serif;
        }
        
        /* Tab Navigation */
        .tab-nav {
            position: fixed;
            top: 0; left: 0; right: 0;
            height: 48px;
            display: flex;
            justify-content: center;
            z-index: 2000;
            background: rgba(15, 35, 50, 0.98);
            border-bottom: 1px solid rgba(255, 255, 255, 0.15);
        }
        
        .tab-btn {
            padding: 0 32px;
            height: 48px;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            cursor: pointer;
            letter-spacing: 2px;
            text-transform: uppercase;
            transition: all 0.3s;
            border-bottom: 2px solid transparent;
        }
        
        .tab-btn:hover { color: rgba(255, 255, 255, 0.85); background: rgba(255, 255, 255, 0.05); }
        .tab-btn.active { color: #6fc; border-bottom-color: #6fc; background: rgba(100, 255, 180, 0.08); }
        
        .tab-content { 
            display: none; 
            position: fixed; 
            top: 48px; left: 0; right: 0; bottom: 0;
            overflow: hidden;
        }
        .tab-content.active { display: block; }
        
        /* ==================== TAB 1: SIMULATION ==================== */
        #tab1 {
            display: none;
            background: #0d1825;
        }
        #tab1.active {
            display: grid;
            grid-template-columns: 360px 1fr;
            grid-template-rows: 1fr;
        }
        
        .tutorial-panel {
            background: rgba(15, 30, 45, 0.98);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .step-header {
            padding: 16px 20px;
            background: rgba(10, 25, 40, 0.95);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .step-progress { display: flex; gap: 5px; margin-bottom: 10px; }
        
        .step-dot {
            width: 8px; height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .step-dot.active { background: #6fc; box-shadow: 0 0 8px #6fc; }
        .step-dot.complete { background: #4af; }
        
        .step-title { font-size: 1.15rem; color: #fff; font-style: italic; }
        
        .tutorial-content {
            flex: 1;
            overflow-y: auto;
            padding: 18px;
        }
        
        .tutorial-content::-webkit-scrollbar { width: 5px; }
        .tutorial-content::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); }
        .tutorial-content::-webkit-scrollbar-thumb { background: rgba(100,255,180,0.3); border-radius: 3px; }
        
        .step-content { display: none; }
        .step-content.active { display: block; }
        
        .section-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: rgba(100, 255, 180, 0.7);
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 10px;
        }
        
        .tutorial-text {
            font-size: 15px;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.6;
            margin-bottom: 12px;
        }
        
        .tutorial-text strong { color: #6fc; font-weight: 500; }
        
        .concept-card {
            background: rgba(0, 40, 30, 0.5);
            border: 1px solid rgba(100, 255, 180, 0.2);
            border-radius: 6px;
            padding: 12px;
            margin: 10px 0;
        }
        
        .concept-card h4 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #6fc;
            margin-bottom: 5px;
            font-weight: 400;
        }
        
        .concept-card p { font-size: 13px; color: rgba(255, 255, 255, 0.7); line-height: 1.5; }
        
        .equation-box {
            background: rgba(0, 30, 25, 0.8);
            border: 1px solid rgba(100, 255, 180, 0.3);
            border-radius: 6px;
            padding: 12px;
            margin: 12px 0;
            text-align: center;
        }
        
        .equation-box .label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            color: rgba(100, 255, 180, 0.7);
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-bottom: 5px;
        }
        
        .equation-box .formula { font-size: 16px; color: #fff; font-style: italic; }
        
        .key-insight {
            background: rgba(100, 200, 255, 0.08);
            border-left: 3px solid rgba(100, 200, 255, 0.5);
            border-radius: 0 6px 6px 0;
            padding: 12px;
            margin: 12px 0;
        }
        
        .key-insight::before {
            content: 'üåÄ CRR INSIGHT';
            display: block;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            color: #4af;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }
        
        .key-insight p { font-size: 13px; color: rgba(255, 255, 255, 0.85); font-style: italic; line-height: 1.5; }
        
        .real-world-box {
            background: rgba(255, 180, 100, 0.08);
            border: 1px solid rgba(255, 180, 100, 0.25);
            border-radius: 6px;
            padding: 12px;
            margin: 12px 0;
        }
        
        .real-world-box::before {
            content: 'üåç PROCESS MAPPING';
            display: block;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            color: rgba(255, 180, 100, 0.8);
            letter-spacing: 1px;
            margin-bottom: 8px;
        }
        
        .real-world-box ul { font-size: 12px; color: rgba(255, 255, 255, 0.7); margin-left: 16px; line-height: 1.7; }
        
        .citation {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            color: rgba(255, 255, 255, 0.3);
            margin-top: 12px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .tutorial-nav {
            padding: 14px 18px;
            background: rgba(10, 25, 40, 0.95);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 10px;
        }
        
        .nav-btn {
            flex: 1;
            padding: 10px 14px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .nav-btn:hover { background: rgba(255, 255, 255, 0.12); }
        .nav-btn.primary { background: rgba(100, 255, 180, 0.2); border-color: rgba(100, 255, 180, 0.4); }
        .nav-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        
        /* Simulation Area */
        .sim-area { 
            display: flex; 
            flex-direction: column;
            overflow: hidden;
        }
        
        .sim-header {
            padding: 8px 16px;
            background: rgba(15, 30, 45, 0.95);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .sim-title { font-size: 12px; color: #fff; font-style: italic; }
        .sim-controls { display: flex; gap: 6px; }
        
        .sim-btn {
            padding: 5px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .sim-btn:hover { background: rgba(255, 255, 255, 0.15); }
        .sim-btn.active { background: rgba(100, 255, 180, 0.2); border-color: #6fc; }
        
        .control-panel {
            padding: 10px 16px;
            background: rgba(15, 30, 45, 0.95);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 24px;
            flex-shrink: 0;
        }
        
        .control-group { flex: 1; }
        
        .control-group label {
            display: block;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 5px;
        }
        
        .control-group label strong { color: #6fc; }
        
        .slider-row { display: flex; align-items: center; gap: 8px; }
        
        .slider-row input[type="range"] {
            flex: 1;
            height: 3px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, rgba(100, 255, 180, 0.5), rgba(255, 180, 100, 0.5));
            border-radius: 2px;
        }
        
        .slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px; height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .slider-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #6fc;
            min-width: 28px;
            text-align: right;
        }
        
        .canvas-wrap { 
            flex: 1; 
            position: relative; 
            background: #0a1520;
            min-height: 200px;
        }
        #simCanvas { width: 100%; height: 100%; display: block; }
        
        .thought {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            color: #0d1825;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            max-width: 140px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            font-style: italic;
        }
        
        .thought.show { opacity: 1; }
        
        /* Data Panels */
        .data-panels {
            display: flex;
            gap: 10px;
            padding: 10px 16px;
            background: rgba(10, 25, 40, 0.98);
            flex-shrink: 0;
        }
        
        .data-panel {
            flex: 1;
            background: rgba(0, 30, 25, 0.7);
            border: 1px solid rgba(100, 255, 180, 0.15);
            border-radius: 5px;
            padding: 10px;
        }
        
        .data-panel h5 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 8px;
            color: #6fc;
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        
        .belief-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; }
        
        .belief-item {
            background: rgba(255, 255, 255, 0.04);
            border-radius: 3px;
            padding: 5px;
            text-align: center;
            transition: all 0.3s;
        }
        
        .belief-item.active { background: rgba(100, 255, 180, 0.12); box-shadow: inset 0 0 0 1px rgba(100, 255, 180, 0.3); }
        
        .belief-item .loc { font-family: 'JetBrains Mono', monospace; font-size: 7px; color: rgba(255, 255, 255, 0.4); }
        .belief-item .prob { font-size: 13px; color: #fff; }
        
        .efe-row {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 2px;
            margin-bottom: 4px;
        }
        
        .efe-row.selected { background: rgba(100, 255, 180, 0.1); border-radius: 3px; }
        
        .efe-row .name { font-family: 'JetBrains Mono', monospace; font-size: 9px; width: 45px; color: rgba(255, 255, 255, 0.6); }
        .efe-row.selected .name { color: #6fc; }
        
        .efe-bar {
            flex: 1;
            height: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 2px;
            overflow: hidden;
            display: flex;
        }
        
        .efe-bar .e { background: rgba(100, 255, 180, 0.7); height: 100%; transition: width 0.3s; }
        .efe-bar .p { background: rgba(255, 180, 100, 0.7); height: 100%; transition: width 0.3s; }
        
        .stats-bar {
            padding: 6px 16px;
            background: rgba(10, 20, 35, 0.98);
            display: flex;
            justify-content: space-between;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }
        
        .stats-bar .stat { display: flex; gap: 4px; }
        .stats-bar .stat-l { color: rgba(255, 255, 255, 0.3); }
        .stats-bar .stat-v { color: #6fc; }
        
        /* ==================== TAB 2: PHASE SPACE ==================== */
        #tab2 {
            background: linear-gradient(135deg, #0d1825 0%, #1a2a3a 100%);
            overflow-y: auto;
        }
        
        .phase-container {
            display: grid;
            grid-template-columns: 1fr 340px;
            gap: 20px;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
            min-height: calc(100vh - 48px - 120px);
        }
        
        .phase-left {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .phase-title { text-align: center; }
        .phase-title h2 { font-size: 22px; font-weight: 300; color: #fff; margin-bottom: 4px; }
        .phase-subtitle { font-family: 'JetBrains Mono', monospace; font-size: 10px; color: rgba(100, 255, 180, 0.7); letter-spacing: 1px; }
        
        .phase-canvas-wrap {
            flex: 1;
            background: rgba(0, 10, 20, 0.9);
            border: 1px solid rgba(100, 255, 180, 0.2);
            border-radius: 10px;
            overflow: hidden;
            min-height: 400px;
        }
        
        #phaseCanvas { width: 100%; height: 100%; display: block; }
        
        .phase-legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.6);
        }
        
        .legend-item { display: flex; align-items: center; gap: 6px; }
        
        .legend-dot {
            width: 12px; height: 12px;
            border-radius: 50%;
        }
        
        .legend-dot.coherence { background: #6fc; box-shadow: 0 0 8px #6fc; }
        .legend-dot.regeneration { background: #ffb870; box-shadow: 0 0 8px #ffb870; }
        .legend-dot.agent { background: #fff; box-shadow: 0 0 10px #fff; }
        
        .legend-line {
            width: 20px; height: 2px;
            background: linear-gradient(90deg, rgba(100,255,180,0.5), rgba(255,180,100,0.5));
        }
        
        .phase-right {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .phase-controls {
            background: rgba(0, 30, 25, 0.8);
            border: 1px solid rgba(100, 255, 180, 0.2);
            border-radius: 10px;
            padding: 18px;
        }
        
        .phase-controls h3 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #6fc;
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-bottom: 14px;
        }
        
        .phase-control { margin-bottom: 16px; }
        .phase-control:last-of-type { margin-bottom: 12px; }
        
        .phase-control label {
            display: block;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 3px;
        }
        
        .phase-control label strong { color: #6fc; }
        
        .control-desc {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.4);
            margin-bottom: 8px;
            font-style: italic;
        }
        
        .phase-control .slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .slider-end {
            font-family: 'JetBrains Mono', monospace;
            font-size: 8px;
            color: rgba(255, 255, 255, 0.35);
            min-width: 45px;
        }
        
        .slider-end:last-child { text-align: right; }
        
        .phase-control input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        
        .phase-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px; height: 16px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .slider-val {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #6fc;
            text-align: center;
            margin-top: 4px;
        }
        
        .phase-btn {
            width: 100%;
            padding: 10px;
            background: rgba(100, 255, 180, 0.15);
            border: 1px solid rgba(100, 255, 180, 0.3);
            color: #fff;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .phase-btn:hover { background: rgba(100, 255, 180, 0.25); }
        
        .phase-readout {
            background: rgba(0, 30, 25, 0.8);
            border: 1px solid rgba(100, 255, 180, 0.2);
            border-radius: 10px;
            padding: 18px;
        }
        
        .phase-readout h3 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: #6fc;
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-bottom: 12px;
        }
        
        .readout-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .readout-row.total { margin-top: 12px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); }
        
        .readout-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            color: rgba(255, 255, 255, 0.5);
            min-width: 85px;
        }
        
        .readout-bar {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .readout-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }
        
        .readout-fill.coherence { background: linear-gradient(90deg, #40a080, #6fc); }
        .readout-fill.regeneration { background: linear-gradient(90deg, #cc9050, #ffb870); }
        .readout-fill.total { background: linear-gradient(90deg, #3080a0, #4af); }
        
        .readout-val {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #fff;
            min-width: 40px;
            text-align: right;
        }
        
        .phase-insight {
            background: rgba(100, 200, 255, 0.08);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 10px;
            padding: 14px;
            display: flex;
            gap: 10px;
        }
        
        .insight-icon { font-size: 18px; }
        
        .phase-insight p {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.5;
            font-style: italic;
        }
        
        .phase-quote {
            max-width: 1200px;
            margin: 0 auto;
            padding: 16px 20px;
            background: rgba(0, 30, 25, 0.6);
            border: 1px solid rgba(100, 255, 180, 0.2);
            border-radius: 8px;
            margin-left: 20px;
            margin-right: 20px;
            margin-bottom: 20px;
        }
        
        .phase-quote p {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.6;
            font-style: italic;
        }
        
        .phase-quote p em { color: #6fc; font-style: normal; }
        
        .phase-quote .source {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            color: rgba(255, 255, 255, 0.3);
            margin-top: 8px;
            text-align: right;
        }
        
        /* ==================== TAB 3: GLOSSARY ==================== */
        #tab3 {
            background: linear-gradient(135deg, #1a2a3a 0%, #0d1825 100%);
            overflow-y: auto;
            padding: 25px 35px 50px;
        }
        
        .glossary-container { max-width: 1000px; margin: 0 auto; }
        .glossary-title { text-align: center; margin-bottom: 25px; }
        .glossary-title h2 { font-size: 26px; font-weight: 300; color: #fff; margin-bottom: 4px; }
        .glossary-subtitle { font-family: 'JetBrains Mono', monospace; font-size: 10px; color: rgba(100, 255, 180, 0.7); letter-spacing: 2px; }
        
        .glossary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 12px; }
        
        .glossary-card {
            background: rgba(0, 30, 25, 0.6);
            border: 1px solid rgba(100, 255, 180, 0.15);
            border-radius: 8px;
            padding: 14px;
            transition: all 0.3s;
        }
        
        .glossary-card:hover { border-color: rgba(100, 255, 180, 0.35); background: rgba(0, 40, 30, 0.7); }
        
        .glossary-card .term {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #6fc;
            margin-bottom: 6px;
        }
        
        .glossary-card .definition {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.75);
            line-height: 1.5;
        }
        
        .glossary-card .definition em { color: #fff; font-style: italic; }
        
        .glossary-card .analogy {
            display: block;
            margin-top: 6px;
            font-size: 11px;
            color: rgba(255, 180, 100, 0.7);
            font-style: italic;
        }
        
        .credit {
            position: fixed;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            color: rgba(255, 255, 255, 0.25);
            z-index: 1000;
        }
        .credit a { color: rgba(100, 255, 180, 0.4); text-decoration: none; }
        .credit a:hover { color: rgba(100, 255, 180, 0.7); }
    </style>
</head>
<body>
    <nav class="tab-nav">
        <button class="tab-btn active" data-tab="tab1">Simulation</button>
        <button class="tab-btn" data-tab="tab2">Phase Space</button>
        <button class="tab-btn" data-tab="tab3">CRR Glossary</button>
    </nav>
    
    <!-- ==================== TAB 1: SIMULATION ==================== -->
    <div id="tab1" class="tab-content active">
        <div class="tutorial-panel">
            <div class="step-header">
                <div class="step-progress" id="stepProgress"></div>
                <div class="step-title" id="stepTitle">The T-Maze Problem</div>
            </div>
            
            <div class="tutorial-content">
                <!-- Step 0: Introduction -->
                <div class="step-content active" data-step="0">
                    <div class="section-label">CRR Framework</div>
                    <p class="tutorial-text">
                        A rat faces a <strong>T-shaped maze</strong>. At the junction, it must choose: go left or go right? One side has cheese üßÄ, the other an electric shock ‚ö°.
                    </p>
                    <p class="tutorial-text">
                        But first it can visit a <strong>cue location</strong> that reveals which side is safe. This simple setup reveals the <strong>Coherence-Rupture-Regeneration</strong> dynamics of decision-making.
                    </p>
                    
                    <div class="concept-card">
                        <h4>C ‚Üí Œ¥ ‚Üí R</h4>
                        <p>
                            The rat <em>accumulates coherence</em> (builds certainty through observation), 
                            experiences <em>rupture</em> (the decision moment), 
                            and <em>regenerates</em> (selects action based on memory-weighted integration).
                        </p>
                    </div>
                    
                    <div class="key-insight">
                        <p>
                            CRR treats each decision as a scale-invariant process: the agent metabolizes its accumulated past into future action at the rupture point Œ¥(now).
                        </p>
                    </div>
                </div>
                
                <!-- Step 1: The Cue -->
                <div class="step-content" data-step="1">
                    <div class="section-label">Coherence Building</div>
                    <p class="tutorial-text">
                        The <strong>cue location</strong> is where <strong>coherence accumulates</strong>. Before visiting, the rat has low coherence about context ‚Äî uncertainty about which side is safe.
                    </p>
                    <p class="tutorial-text">
                        After visiting the cue, <strong>coherence is high</strong>: the rat now has integrated, consistent knowledge about its environment.
                    </p>
                    
                    <div class="equation-box">
                        <div class="label">Coherence Integral</div>
                        <div class="formula">C(x,t) = ‚à´ L(x,œÑ) dœÑ</div>
                    </div>
                    
                    <p class="tutorial-text">
                        L represents the <strong>local coherence field</strong> ‚Äî how consistent the agent's state is with its environment at each moment.
                    </p>
                    
                    <div class="real-world-box">
                        <ul>
                            <li>Before cue: C ‚âà 0.5 (uncertain, incoherent)</li>
                            <li>After cue: C ‚âà 0.98 (certain, coherent)</li>
                            <li>Each observation integrates into the coherence field</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Step 2: The Model -->
                <div class="step-content" data-step="2">
                    <div class="section-label">The Temporal Structure</div>
                    <p class="tutorial-text">
                        CRR uses a <strong>generative process</strong> with explicit temporal dynamics:
                    </p>
                    
                    <div class="concept-card">
                        <h4>Coherence Field</h4>
                        <p>How certain the agent is about context. Observation builds coherence; uncertainty depletes it.</p>
                    </div>
                    
                    <div class="concept-card">
                        <h4>Œ© (Omega) ‚Äî Boundary Parameter</h4>
                        <p>Controls how memory is accessed. Low Œ© = only recent high-coherence moments. High Œ© = broad historical access.</p>
                    </div>
                    
                    <div class="concept-card">
                        <h4>Memory Kernel exp(C/Œ©)</h4>
                        <p>Weights past states by coherence. High coherence moments dominate regeneration when Œ© is small.</p>
                    </div>
                    
                    <div class="concept-card">
                        <h4>Reward History</h4>
                        <p>Past experiences of reward/punishment, weighted by coherence at time of experience.</p>
                    </div>
                </div>
                
                <!-- Step 3: Regeneration -->
                <div class="step-content" data-step="3">
                    <div class="section-label">Regeneration Potential</div>
                    <p class="tutorial-text">
                        At each <strong>rupture point</strong> Œ¥(now), the rat evaluates possible actions via <strong>Regeneration Potential (R)</strong>:
                    </p>
                    
                    <div class="equation-box">
                        <div class="label">Regeneration</div>
                        <div class="formula">R = ‚à´ œÜ(x,œÑ) ¬∑ exp(C/Œ©) ¬∑ Œò(...) dœÑ</div>
                    </div>
                    
                    <p class="tutorial-text">
                        This decomposes into two natural components:
                    </p>
                    
                    <div class="concept-card">
                        <h4>Coherence-Building Value</h4>
                        <p>How much visiting a location will <em>increase</em> coherence. The cue has high coherence-building value when uncertainty is high.</p>
                    </div>
                    
                    <div class="concept-card">
                        <h4>Memory-Weighted Preference</h4>
                        <p>Expected outcome weighted by exp(C/Œ©). Higher coherence about reward location ‚Üí stronger pull toward that action.</p>
                    </div>
                    
                    <div class="key-insight">
                        <p>
                            CRR naturally balances "information seeking" and "reward seeking" through the exp(C/Œ©) weighting ‚Äî both serve coherent regeneration.
                        </p>
                    </div>
                </div>
                
                <!-- Step 4: Omega -->
                <div class="step-content" data-step="4">
                    <div class="section-label">The Œ© Parameter</div>
                    <p class="tutorial-text">
                        <strong>Œ© (omega)</strong> controls boundary flexibility ‚Äî how the agent accesses its memory during regeneration:
                    </p>
                    
                    <div class="equation-box">
                        <div class="label">Policy Selection</div>
                        <div class="formula">P(œÄ) ‚àù exp(R(œÄ) / Œ©)</div>
                    </div>
                    
                    <p class="tutorial-text">
                        <strong>Low Œ©</strong>: Only highest-coherence memories accessible. Peaked, decisive action selection. The agent acts on its most certain knowledge.
                    </p>
                    <p class="tutorial-text">
                        <strong>High Œ©</strong>: Broad memory access. More exploratory, considers diverse possibilities. The agent remains open to alternatives.
                    </p>
                    
                    <div class="real-world-box">
                        <ul>
                            <li>Low Œ© ‚Üí Habitual, pattern-reconstituting</li>
                            <li>High Œ© ‚Üí Adaptive, exploratory</li>
                            <li>Contemplatives train Œ© control through practice</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Step 5: Behaviour -->
                <div class="step-content" data-step="5">
                    <div class="section-label">Emergent Behaviour</div>
                    <p class="tutorial-text">
                        Watch the rat's behaviour emerge from CRR dynamics. With <strong>low initial coherence</strong>, the cue has high coherence-building value ‚Üí the rat visits it first.
                    </p>
                    <p class="tutorial-text">
                        After building coherence at the cue, the <strong>memory-weighted preference</strong> for the correct side dominates ‚Üí the rat goes to the cheese.
                    </p>
                    
                    <div class="key-insight">
                        <p>
                            "Exploration vs exploitation" dissolves in CRR: both are aspects of coherent regeneration. Information-seeking builds coherence; reward-seeking realizes it.
                        </p>
                    </div>
                    
                    <p class="tutorial-text">
                        Adjust the sliders to see how <strong>coherence weight</strong>, <strong>preference weight</strong>, and <strong>Œ©</strong> affect the rat's choices.
                    </p>
                    
                    <div class="citation">
                        CRR Framework ‚Äî Sabine (2024-2025)<br>
                        Coherence-Rupture-Regeneration dynamics
                    </div>
                </div>
            </div>
            
            <div class="tutorial-nav">
                <button class="nav-btn" id="prevBtn" disabled>‚Üê BACK</button>
                <button class="nav-btn primary" id="nextBtn">NEXT ‚Üí</button>
            </div>
        </div>
        
        <div class="sim-area">
            <div class="sim-header">
                <span class="sim-title">CRR T-Maze Simulation</span>
                <div class="sim-controls">
                    <button class="sim-btn" id="stepBtn">STEP</button>
                    <button class="sim-btn" id="autoBtn">AUTO</button>
                    <button class="sim-btn" id="resetBtn">RESET</button>
                </div>
            </div>
            
            <div class="control-panel">
                <div class="control-group">
                    <label><strong>Œ©</strong> ‚Äî Boundary Flexibility</label>
                    <div class="slider-row">
                        <input type="range" id="precSlider" min="0.5" max="8" step="0.5" value="4">
                        <span class="slider-value" id="precValue">4.0</span>
                    </div>
                </div>
                <div class="control-group">
                    <label><strong>Coherence Weight</strong> ‚Äî Information value</label>
                    <div class="slider-row">
                        <input type="range" id="epiSlider" min="0" max="3" step="0.1" value="1.5">
                        <span class="slider-value" id="epiValue">1.5</span>
                    </div>
                </div>
                <div class="control-group">
                    <label><strong>Preference</strong> ‚Äî Reward: <span id="prefR">+6</span> | Shock: <span id="prefS">-6</span></label>
                    <div class="slider-row">
                        <input type="range" id="prefSlider" min="1" max="10" step="1" value="6">
                        <span class="slider-value" id="prefValue">6</span>
                    </div>
                </div>
            </div>
            
            <div class="canvas-wrap">
                <canvas id="simCanvas"></canvas>
                <div class="thought" id="thought"></div>
            </div>
            
            <div class="data-panels">
                <div class="data-panel">
                    <h5>Coherence Field (Context)</h5>
                    <div class="belief-grid">
                        <div class="belief-item" id="belLeft">
                            <div class="loc">LEFT</div>
                            <div class="prob" id="belLeftVal">50%</div>
                        </div>
                        <div class="belief-item" id="belRight">
                            <div class="loc">RIGHT</div>
                            <div class="prob" id="belRightVal">50%</div>
                        </div>
                    </div>
                </div>
                <div class="data-panel">
                    <h5>Regeneration Potential (R)</h5>
                    <div class="efe-row" id="efeCue">
                        <span class="name">CUE</span>
                        <div class="efe-bar"><div class="e" id="efeCueC"></div><div class="p" id="efeCueP"></div></div>
                    </div>
                    <div class="efe-row" id="efeLeft">
                        <span class="name">LEFT</span>
                        <div class="efe-bar"><div class="e" id="efeLeftC"></div><div class="p" id="efeLeftP"></div></div>
                    </div>
                    <div class="efe-row" id="efeRight">
                        <span class="name">RIGHT</span>
                        <div class="efe-bar"><div class="e" id="efeRightC"></div><div class="p" id="efeRightP"></div></div>
                    </div>
                </div>
            </div>
            
            <div class="stats-bar">
                <div class="stat"><span class="stat-l">REWARDS:</span><span class="stat-v" id="statRew">0</span></div>
                <div class="stat"><span class="stat-l">SHOCKS:</span><span class="stat-v" id="statShk">0</span></div>
                <div class="stat"><span class="stat-l">TRIALS:</span><span class="stat-v" id="statTri">1</span></div>
                <div class="stat"><span class="stat-l">STEP:</span><span class="stat-v" id="statStep">1</span></div>
            </div>
        </div>
    </div>
    
    <!-- ==================== TAB 2: PHASE SPACE ==================== -->
    <div id="tab2" class="tab-content">
        <div class="phase-container">
            <div class="phase-left">
                <div class="phase-title">
                    <h2>CRR Dynamics in Phase Space</h2>
                    <div class="phase-subtitle">Coherence and Regeneration Attractors</div>
                </div>
                
                <div class="phase-canvas-wrap">
                    <canvas id="phaseCanvas"></canvas>
                </div>
                
                <div class="phase-legend">
                    <div class="legend-item"><div class="legend-dot coherence"></div><span>Coherence Attractor</span></div>
                    <div class="legend-item"><div class="legend-dot regeneration"></div><span>Regeneration Attractor</span></div>
                    <div class="legend-item"><div class="legend-dot agent"></div><span>Agent State</span></div>
                    <div class="legend-item"><div class="legend-line"></div><span>Flow Field</span></div>
                </div>
            </div>
            
            <div class="phase-right">
                <div class="phase-controls">
                    <h3>CRR Parameters</h3>
                    
                    <div class="phase-control">
                        <label><strong>Initial Coherence</strong></label>
                        <div class="control-desc">Current certainty about context (0 = incoherent, 1 = fully coherent)</div>
                        <div class="slider-row">
                            <span class="slider-end">LOW</span>
                            <input type="range" id="phaseUnc" min="0" max="1" step="0.05" value="0.2">
                            <span class="slider-end">HIGH</span>
                        </div>
                        <div class="slider-val" id="phaseUncVal">20%</div>
                    </div>
                    
                    <div class="phase-control">
                        <label><strong>Coherence Weight</strong></label>
                        <div class="control-desc">Importance of building coherence (information value)</div>
                        <div class="slider-row">
                            <span class="slider-end">LOW</span>
                            <input type="range" id="phaseEpi" min="0" max="2" step="0.1" value="1">
                            <span class="slider-end">HIGH</span>
                        </div>
                        <div class="slider-val" id="phaseEpiVal">1.0</div>
                    </div>
                    
                    <div class="phase-control">
                        <label><strong>Preference Weight</strong></label>
                        <div class="control-desc">Importance of memory-weighted reward (regeneration pull)</div>
                        <div class="slider-row">
                            <span class="slider-end">LOW</span>
                            <input type="range" id="phasePrag" min="0" max="2" step="0.1" value="1">
                            <span class="slider-end">HIGH</span>
                        </div>
                        <div class="slider-val" id="phasePragVal">1.0</div>
                    </div>
                    
                    <div class="phase-control">
                        <label><strong>Œ© (Omega)</strong></label>
                        <div class="control-desc">Boundary flexibility: Low = peaked/decisive, High = broad/exploratory</div>
                        <div class="slider-row">
                            <span class="slider-end">RIGID</span>
                            <input type="range" id="phasePrec" min="0.5" max="5" step="0.1" value="2">
                            <span class="slider-end">FLEXIBLE</span>
                        </div>
                        <div class="slider-val" id="phasePrecVal">Œ© = 2.0</div>
                    </div>
                    
                    <button class="phase-btn" id="phaseReset">Reset Agent Position</button>
                </div>
                
                <div class="phase-readout">
                    <h3>Live CRR Decomposition</h3>
                    <div class="readout-row">
                        <span class="readout-label">Coherence pull:</span>
                        <div class="readout-bar"><div class="readout-fill coherence" id="readoutE"></div></div>
                        <span class="readout-val" id="readoutEVal">0.00</span>
                    </div>
                    <div class="readout-row">
                        <span class="readout-label">Regen. pull:</span>
                        <div class="readout-bar"><div class="readout-fill regeneration" id="readoutP"></div></div>
                        <span class="readout-val" id="readoutPVal">0.00</span>
                    </div>
                    <div class="readout-row total">
                        <span class="readout-label">Combined R:</span>
                        <div class="readout-bar"><div class="readout-fill total" id="readoutG"></div></div>
                        <span class="readout-val" id="readoutGVal">0.00</span>
                    </div>
                </div>
                
                <div class="phase-insight">
                    <div class="insight-icon">üåÄ</div>
                    <p id="phaseInsight">Low coherence ‚Üí agent seeks information first (coherence attractor dominates).</p>
                </div>
            </div>
        </div>
        
        <div class="phase-quote">
            <p>"At rupture, the agent <em>metabolizes accumulated coherence into future action</em>. The exp(C/Œ©) weighting ensures that high-coherence moments dominate regeneration ‚Äî we act from what we know most clearly."</p>
            <div class="source">‚Äî CRR Framework: Coherence-Rupture-Regeneration</div>
        </div>
    </div>
    
    <!-- ==================== TAB 3: GLOSSARY ==================== -->
    <div id="tab3" class="tab-content">
        <div class="glossary-container">
            <div class="glossary-title">
                <h2>CRR Glossary</h2>
                <div class="glossary-subtitle">Coherence-Rupture-Regeneration concepts</div>
            </div>
            
            <div class="glossary-grid">
                <div class="glossary-card">
                    <div class="term">Coherence C(x,t)</div>
                    <div class="definition">Accumulated consistency between agent and environment. <em>C = ‚à´L(x,œÑ)dœÑ</em>.
                        <span class="analogy">High coherence = clear, integrated knowledge.</span>
                    </div>
                </div>
                <div class="glossary-card">
                    <div class="term">Rupture Œ¥(now)</div>
                    <div class="definition">Scale-invariant choice moment. The present instant where past becomes future.
                        <span class="analogy">Every decision is a tiny "now" where you commit.</span>
                    </div>
                </div>
                <div class="glossary-card">
                    <div class="term">Regeneration R</div>
                    <div class="definition">Memory-weighted integration toward action: <em>R = ‚à´œÜ¬∑exp(C/Œ©)¬∑Œò dœÑ</em>.
                        <span class="analogy">You regenerate from your clearest memories.</span>
                    </div>
                </div>
                <div class="glossary-card">
                    <div class="term">Œ© (Omega)</div>
                    <div class="definition">Boundary flexibility parameter. Controls memory access breadth in exp(C/Œ©).
                        <span class="analogy">Low Œ© = peaked focus. High Œ© = broad access.</span>
                    </div>
                </div>
                <div class="glossary-card">
                    <div class="term">exp(C/Œ©)</div>
                    <div class="definition">Memory amplification kernel. Weights past states by coherence.
                        <span class="analogy">Clear memories dominate; fuzzy ones fade.</span>
                    </div>
                </div>
                <div class="glossary-card">
                    <div class="term">Coherence Building</div>
                    <div class="definition">Actions that increase C ‚Äî reduce uncertainty, integrate information.
                        <span class="analogy">Checking the cue builds coherence about context.</span>
                    </div>
                </div>
                <div class="glossary-card">
                    <div class="term">Local Coherence L(x,œÑ)</div>
                    <div class="definition">Instantaneous consistency at location x and time œÑ.
                        <span class="analogy">How "right" does this moment feel?</span>
                    </div>
                </div>
                <div class="glossary-card">
                    <div class="term">Reconstruction œÜ(x,œÑ)</div>
                    <div class="definition">Resources available for regeneration at each past moment.
                        <span class="analogy">What can you build from each memory?</span>
                    </div>
                </div>
                <div class="glossary-card">
                    <div class="term">Policy Selection</div>
                    <div class="definition"><em>P(œÄ) ‚àù exp(R(œÄ)/Œ©)</em>. Actions selected by regeneration potential.
                        <span class="analogy">Do what regenerates you best.</span>
                    </div>
                </div>
                <div class="glossary-card">
                    <div class="term">Z‚ÇÇ Symmetry</div>
                    <div class="definition">Binary switching systems: Œ© = 1/œÄ, CV ‚âà 0.159.
                        <span class="analogy">On/off, left/right, yes/no.</span>
                    </div>
                </div>
                <div class="glossary-card">
                    <div class="term">SO(2) Symmetry</div>
                    <div class="definition">Continuous rotation systems: Œ© = 1/2œÄ, CV ‚âà 0.08.
                        <span class="analogy">Cycles, rhythms, oscillations.</span>
                    </div>
                </div>
                <div class="glossary-card">
                    <div class="term">Metabolization</div>
                    <div class="definition">At Œ¥(now), past coherence is transformed into future action.
                        <span class="analogy">You digest experience into behavior.</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="credit">CRR Framework | Alexander Sabine | <a href="https://cohere.org.uk">cohere.org.uk</a> | <a href="https://temporalgrammar.ai">temporalgrammar.ai</a></div>

<script>
// ============================================================================
// UTILITY
// ============================================================================
const $ = id => document.getElementById(id);

// ============================================================================
// TAB NAVIGATION
// ============================================================================
document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        const id = btn.dataset.tab;
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById(id).classList.add('active');
        
        if (id === 'tab1') setTimeout(() => render.resize(), 10);
        if (id === 'tab2') setTimeout(resizePhaseCanvas, 10);
    });
});

// ============================================================================
// TUTORIAL NAVIGATION
// ============================================================================
const totalSteps = 6;
let currentStep = 0;

// Build step dots
const progressEl = $('stepProgress');
for (let i = 0; i < totalSteps; i++) {
    const dot = document.createElement('div');
    dot.className = 'step-dot' + (i === 0 ? ' active' : '');
    dot.onclick = () => goToStep(i);
    progressEl.appendChild(dot);
}

const stepTitles = [
    "The T-Maze Problem",
    "Coherence Building",
    "The Temporal Structure",
    "Regeneration Potential",
    "The Œ© Parameter",
    "Emergent Behaviour"
];

function goToStep(i) {
    currentStep = i;
    
    // Update dots
    document.querySelectorAll('.step-dot').forEach((d, j) => {
        d.classList.remove('active', 'complete');
        if (j < i) d.classList.add('complete');
        if (j === i) d.classList.add('active');
    });
    
    // Update title
    $('stepTitle').textContent = stepTitles[i];
    
    // Show correct content
    document.querySelectorAll('.step-content').forEach((c, j) => {
        c.classList.toggle('active', j === i);
    });
    
    // Update buttons
    $('prevBtn').disabled = i === 0;
    $('nextBtn').textContent = i === totalSteps - 1 ? 'RESTART ‚Ü∫' : 'NEXT ‚Üí';
}

$('prevBtn').onclick = () => { if (currentStep > 0) goToStep(currentStep - 1); };
$('nextBtn').onclick = () => { goToStep(currentStep < totalSteps - 1 ? currentStep + 1 : 0); };

// ============================================================================
// RAT AGENT ‚Äî CRR-BASED
// ============================================================================
class Rat {
    constructor() {
        this.locs = {center:{x:.5,y:.72}, cue:{x:.5,y:.35}, left:{x:.18,y:.35}, right:{x:.82,y:.35}};
        // CRR parameters: omega (boundary flexibility), coherence weight, preferences
        this.omega = 0.25; // 1/precision ‚Äî lower = more peaked selection
        this.cohW = 1.5;   // coherence building weight
        this.pref = {r:6, s:-6}; // reward/shock preferences
        this.rew = 0; this.shk = 0; this.tri = 0;
        this.reset();
    }
    
    reset() {
        this.loc = 'center'; 
        this.x = .5; this.y = .72; 
        this.tx = .5; this.ty = .72;
        this.ang = 0; this.mov = false; this.ph = 0; this.step = 1;
        this.cueObs = false; 
        this.ctx = Math.random() < .5 ? 'left' : 'right';
        // Coherence field for context: starts at 0.5 (uncertain)
        this.coherence = {left: 0.5, right: 0.5};
        this.tri++;
    }
    
    // Coherence deficit: how far from certainty (high = need information)
    coherenceDeficit() { 
        const c = Math.max(this.coherence.left, this.coherence.right);
        // Returns 0 when certain, 1 when maximally uncertain (c=0.5)
        if (c >= 0.99) return 0;
        return 1 - Math.abs(2 * c - 1); // peaks at c=0.5
    }
    
    // CRR: Regeneration potential for each policy
    // R(œÄ) = coherence_building_value + memory_weighted_preference
    regeneration(pol) {
        let cohBuild = 0, memPref = 0;
        
        if (pol === 'cue') { 
            // Cue builds coherence ‚Äî value proportional to current deficit
            cohBuild = this.coherenceDeficit() * this.cohW * 2;
            // Small memory-weighted preference (cue itself is neutral)
            memPref = 0;
        } else if (pol === 'left') { 
            // Low coherence building (already have location info)
            cohBuild = 0.05 * this.cohW;
            // Memory-weighted preference: exp(C/Œ©) weights by coherence
            // If coherent about left=reward, strong positive pull
            const expWeight = Math.exp(this.coherence.left / (this.omega + 0.1));
            const normWeight = expWeight / (expWeight + Math.exp(this.coherence.right / (this.omega + 0.1)));
            memPref = normWeight * this.pref.r + (1 - normWeight) * this.pref.s;
        } else { // right
            cohBuild = 0.05 * this.cohW;
            const expWeight = Math.exp(this.coherence.right / (this.omega + 0.1));
            const normWeight = expWeight / (expWeight + Math.exp(this.coherence.left / (this.omega + 0.1)));
            memPref = normWeight * this.pref.r + (1 - normWeight) * this.pref.s;
        }
        
        return {c: cohBuild, p: memPref, t: cohBuild + memPref};
    }
    
    validPolicies() { 
        if (this.loc === 'center') return ['cue', 'left', 'right']; 
        if (this.loc === 'cue') return ['left', 'right']; 
        return []; 
    }
    
    // CRR policy selection: P(œÄ) ‚àù exp(R(œÄ) / Œ©)
    selectPolicy() {
        const ps = this.validPolicies();
        if (!ps.length) return null;
        
        const regens = {};
        let maxR = -Infinity;
        ps.forEach(p => { 
            regens[p] = this.regeneration(p); 
            if (regens[p].t > maxR) maxR = regens[p].t; 
        });
        
        // Softmax with temperature Œ© (note: 1/Œ© gives precision-like behavior)
        // Using 1/omega as effective precision for selection sharpness
        const precision = 1 / (this.omega + 0.05);
        let sum = 0;
        const exp = {};
        ps.forEach(p => { 
            exp[p] = Math.exp(precision * (regens[p].t - maxR)); 
            sum += exp[p]; 
        });
        
        const probs = {};
        ps.forEach(p => probs[p] = exp[p] / sum);
        
        // Stochastic selection (rupture moment Œ¥(now))
        const r = Math.random();
        let cumulative = 0;
        for (const p of ps) {
            cumulative += probs[p];
            if (r < cumulative) return {pol: p, probs, regens};
        }
        return {pol: ps[0], probs, regens};
    }
    
    // Execute policy ‚Äî this is the rupture moment Œ¥(now)
    execute(pol) {
        this.loc = pol;
        const l = this.locs[pol];
        this.tx = l.x; this.ty = l.y;
        this.mov = true;
        this.step++;
        
        // Update coherence field based on observation
        if (pol === 'cue' && !this.cueObs) {
            this.cueObs = true;
            // After observing cue, coherence becomes high for true context
            if (this.ctx === 'left') {
                this.coherence = {left: 0.98, right: 0.02};
            } else {
                this.coherence = {left: 0.02, right: 0.98};
            }
        }
        
        // Regeneration outcomes
        if (pol === 'left' || pol === 'right') {
            if (pol === this.ctx) this.rew++;
            else this.shk++;
        }
    }
    
    update(dt) {
        this.ph += dt * 5;
        if (this.mov) {
            const dx = this.tx - this.x;
            const dy = this.ty - this.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            if (d > 0.008) {
                const speed = 0.35 * dt;
                this.x += (dx / d) * speed;
                this.y += (dy / d) * speed;
                this.ang = Math.atan2(dy, dx);
            } else {
                this.x = this.tx;
                this.y = this.ty;
                this.mov = false;
            }
        }
    }
}

// ============================================================================
// RENDERER
// ============================================================================
class Render {
    constructor(canvas, rat) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.rat = rat;
        this.resize();
    }
    
    resize() {
        const parent = this.canvas.parentElement;
        this.canvas.width = parent.clientWidth;
        this.canvas.height = parent.clientHeight;
    }
    
    draw() {
        const ctx = this.ctx;
        const w = this.canvas.width;
        const h = this.canvas.height;
        const r = this.rat;
        
        // Background
        ctx.fillStyle = '#0a1520';
        ctx.fillRect(0, 0, w, h);
        
        // Grid
        ctx.strokeStyle = 'rgba(255,255,255,0.015)';
        for (let i = 0; i < w; i += 40) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, h); ctx.stroke(); }
        for (let i = 0; i < h; i += 40) { ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(w, i); ctx.stroke(); }
        
        // Maze floor
        ctx.fillStyle = 'rgba(60,140,100,0.08)';
        ctx.fillRect(w * 0.38, h * 0.25, w * 0.24, h * 0.55);
        ctx.fillRect(w * 0.08, h * 0.25, w * 0.84, h * 0.18);
        
        // Maze walls
        ctx.shadowColor = '#6fc';
        ctx.shadowBlur = 8;
        ctx.strokeStyle = 'rgba(100,255,180,0.25)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(w * 0.08, h * 0.25);
        ctx.lineTo(w * 0.08, h * 0.43);
        ctx.lineTo(w * 0.38, h * 0.43);
        ctx.lineTo(w * 0.38, h * 0.8);
        ctx.lineTo(w * 0.62, h * 0.8);
        ctx.lineTo(w * 0.62, h * 0.43);
        ctx.lineTo(w * 0.92, h * 0.43);
        ctx.lineTo(w * 0.92, h * 0.25);
        ctx.lineTo(w * 0.08, h * 0.25);
        ctx.stroke();
        ctx.shadowBlur = 0;
        
        // Location labels
        const drawLabel = (px, py, text, active) => {
            ctx.fillStyle = active ? 'rgba(100,255,180,0.1)' : 'rgba(255,255,255,0.02)';
            ctx.beginPath();
            ctx.arc(px, py - 8, 20, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = active ? '#6fc' : 'rgba(255,255,255,0.2)';
            ctx.font = '8px JetBrains Mono, monospace';
            ctx.textAlign = 'center';
            ctx.fillText(text, px, py + 16);
        };
        drawLabel(w * 0.5, h * 0.74, 'CENTRE', r.loc === 'center');
        drawLabel(w * 0.5, h * 0.32, 'CUE', r.loc === 'cue');
        drawLabel(w * 0.18, h * 0.32, 'LEFT', r.loc === 'left');
        drawLabel(w * 0.82, h * 0.32, 'RIGHT', r.loc === 'right');
        
        // Stimuli
        const drawStim = (px, py, isReward) => {
            const size = w * 0.02;
            if (isReward) {
                ctx.fillStyle = '#ffd700';
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.moveTo(px - size, py + size * 0.5);
                ctx.lineTo(px + size, py + size * 0.5);
                ctx.lineTo(px + size * 0.5, py - size * 0.5);
                ctx.closePath();
                ctx.fill();
            } else {
                ctx.fillStyle = '#f44';
                ctx.shadowColor = '#f44';
                ctx.shadowBlur = 6;
                ctx.font = `${size * 1.4}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚ö°', px, py);
            }
            ctx.shadowBlur = 0;
        };
        drawStim(w * 0.18, h * 0.38, r.ctx === 'left');
        drawStim(w * 0.82, h * 0.38, r.ctx === 'right');
        
        // Cue indicator
        ctx.strokeStyle = r.cueObs ? 'rgba(100,255,180,0.8)' : 'rgba(100,200,255,0.4)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        const cueX = w * 0.5, cueY = h * 0.32;
        if (r.cueObs) {
            // Show which way cue pointed
            const arrowDir = r.ctx === 'left' ? -1 : 1;
            ctx.moveTo(cueX - 10 * arrowDir, cueY - 5);
            ctx.lineTo(cueX + 10 * arrowDir, cueY);
            ctx.lineTo(cueX - 10 * arrowDir, cueY + 5);
        } else {
            ctx.moveTo(cueX - 8, cueY);
            ctx.lineTo(cueX + 8, cueY);
            ctx.moveTo(cueX, cueY - 8);
            ctx.lineTo(cueX, cueY + 8);
        }
        ctx.stroke();
        
        // Draw rat
        const rx = r.x * w, ry = r.y * h;
        
        // Body glow
        ctx.fillStyle = 'rgba(200,220,255,0.08)';
        ctx.beginPath();
        ctx.arc(rx, ry, 25 + Math.sin(r.ph) * 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Body
        ctx.fillStyle = '#aab';
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 5;
        ctx.beginPath();
        ctx.ellipse(rx, ry, 12, 8, r.ang, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Head direction
        ctx.fillStyle = '#ccd';
        ctx.beginPath();
        ctx.arc(rx + Math.cos(r.ang) * 8, ry + Math.sin(r.ang) * 8, 5, 0, Math.PI * 2);
        ctx.fill();
        
        // Eyes
        ctx.fillStyle = '#222';
        const eyeOff = Math.PI / 3;
        ctx.beginPath();
        ctx.arc(rx + Math.cos(r.ang + eyeOff) * 10, ry + Math.sin(r.ang + eyeOff) * 10, 2, 0, Math.PI * 2);
        ctx.arc(rx + Math.cos(r.ang - eyeOff) * 10, ry + Math.sin(r.ang - eyeOff) * 10, 2, 0, Math.PI * 2);
        ctx.fill();
    }
}

// ============================================================================
// MAIN SIMULATION
// ============================================================================
const canvas = $('simCanvas');
const rat = new Rat();
const render = new Render(canvas, rat);

let autoRun = false;
let lastTime = 0;

// Slider handlers
$('precSlider').oninput = e => {
    // Convert precision slider to omega (inverse relationship)
    // High slider value = low omega = more decisive
    const prec = parseFloat(e.target.value);
    rat.omega = 1 / prec;
    $('precValue').textContent = prec.toFixed(1);
};

$('epiSlider').oninput = e => {
    rat.cohW = parseFloat(e.target.value);
    $('epiValue').textContent = rat.cohW.toFixed(1);
};

$('prefSlider').oninput = e => {
    const v = parseInt(e.target.value);
    rat.pref = {r: v, s: -v};
    $('prefR').textContent = '+' + v;
    $('prefS').textContent = '-' + v;
    $('prefValue').textContent = v;
};

$('stepBtn').onclick = () => {
    if (!rat.mov) {
        const result = rat.selectPolicy();
        if (result) {
            rat.execute(result.pol);
            showThought(result);
        } else {
            rat.reset();
        }
        updateUI();
    }
};

$('autoBtn').onclick = () => {
    autoRun = !autoRun;
    $('autoBtn').classList.toggle('active', autoRun);
};

$('resetBtn').onclick = () => {
    rat.reset();
    updateUI();
};

function showThought(result) {
    const thought = $('thought');
    const rect = canvas.getBoundingClientRect();
    const x = rat.x * canvas.width;
    const y = rat.y * canvas.height;
    
    thought.style.left = (x + 30) + 'px';
    thought.style.top = (y - 20) + 'px';
    
    // CRR-flavored thoughts
    const regen = result.regens[result.pol];
    if (result.pol === 'cue') {
        thought.textContent = `Building coherence... (C: ${regen.c.toFixed(2)})`;
    } else {
        const dir = result.pol === 'left' ? '‚Üê' : '‚Üí';
        thought.textContent = `Regenerating ${dir} (R: ${regen.t.toFixed(2)})`;
    }
    
    thought.classList.add('show');
    setTimeout(() => thought.classList.remove('show'), 1500);
}

function updateUI() {
    // Coherence field display
    $('belLeftVal').textContent = Math.round(rat.coherence.left * 100) + '%';
    $('belRightVal').textContent = Math.round(rat.coherence.right * 100) + '%';
    $('belLeft').classList.toggle('active', rat.coherence.left > 0.6);
    $('belRight').classList.toggle('active', rat.coherence.right > 0.6);
    
    // Regeneration bars
    const policies = rat.validPolicies();
    const regens = {};
    let maxT = 0.1;
    policies.forEach(p => {
        regens[p] = rat.regeneration(p);
        maxT = Math.max(maxT, Math.abs(regens[p].t));
    });
    
    const updateBar = (pol, cId, pId, rowId) => {
        const r = regens[pol] || {c: 0, p: 0, t: 0};
        const scale = 50 / maxT;
        $(cId).style.width = Math.max(0, r.c * scale) + '%';
        $(pId).style.width = Math.max(0, (r.p + 6) * scale / 2) + '%';
        $(rowId).classList.toggle('selected', policies.includes(pol) && r.t === Math.max(...policies.map(p => regens[p]?.t || 0)));
    };
    
    updateBar('cue', 'efeCueC', 'efeCueP', 'efeCue');
    updateBar('left', 'efeLeftC', 'efeLeftP', 'efeLeft');
    updateBar('right', 'efeRightC', 'efeRightP', 'efeRight');
    
    // Stats
    $('statRew').textContent = rat.rew;
    $('statShk').textContent = rat.shk;
    $('statTri').textContent = rat.tri;
    $('statStep').textContent = rat.step;
}

function loop(time) {
    const dt = Math.min((time - lastTime) / 1000, 0.1);
    lastTime = time;
    
    rat.update(dt);
    
    if (autoRun && !rat.mov) {
        const policies = rat.validPolicies();
        if (policies.length) {
            setTimeout(() => {
                if (autoRun) {
                    const result = rat.selectPolicy();
                    if (result) {
                        rat.execute(result.pol);
                        showThought(result);
                    }
                }
            }, 400);
        } else {
            setTimeout(() => { if (autoRun) { rat.reset(); updateUI(); } }, 800);
        }
    }
    
    render.draw();
    updateUI();
    requestAnimationFrame(loop);
}

// ============================================================================
// TAB 2: PHASE SPACE VISUALIZATION ‚Äî CRR VERSION
// ============================================================================
const phaseCanvas = $('phaseCanvas');
let phaseCtx = null;

const phase = {
    coherence: 0.2,      // current coherence level (0-1)
    cohWeight: 1.0,      // coherence building weight
    prefWeight: 1.0,     // preference/regeneration weight  
    omega: 0.5,          // boundary flexibility
    agent: { x: 0.5, y: 0.85, vx: 0, vy: 0, trail: [] },
    time: 0
};

// Attractor positions with rgba colors for gradients
const attractors = {
    coherence: { x: 0.5, y: 0.25, label: 'COHERENCE', color: '#6fc', rgba: 'rgba(100,255,180,' },
    regenLeft: { x: 0.15, y: 0.25, label: 'LEFT üßÄ', color: '#66ffcc', rgba: 'rgba(102,255,204,' },
    regenRight: { x: 0.85, y: 0.25, label: 'RIGHT', color: '#ffb870', rgba: 'rgba(255,184,112,' }
};

function calcCRR() {
    const c = phase.coherence;
    const cW = phase.cohWeight;
    const pW = phase.prefWeight;
    
    // Coherence deficit: peaks when uncertain (c ‚âà 0.5)
    const deficit = 1 - Math.abs(2 * c - 1);
    
    // Coherence building value (like epistemic value)
    const cohValue = deficit * cW * 2;
    
    // Memory-weighted regeneration toward each side
    // Assume left is "correct" for visualization; coherence c represents P(left correct)
    const expLeft = Math.exp(c / (phase.omega + 0.1));
    const expRight = Math.exp((1-c) / (phase.omega + 0.1));
    const normLeft = expLeft / (expLeft + expRight);
    const normRight = 1 - normLeft;
    
    // Regeneration pull (memory-weighted preference)
    const regenLeft = (normLeft * 6 + normRight * -6) * pW / 6;
    const regenRight = (normRight * 6 + normLeft * -6) * pW / 6;
    
    return { cohValue, regenLeft, regenRight };
}

function getForces() {
    const crr = calcCRR();
    const ax = phase.agent.x;
    const ay = phase.agent.y;
    
    let fx = 0, fy = 0;
    
    // Coherence attractor pull (information seeking)
    const cDx = attractors.coherence.x - ax;
    const cDy = attractors.coherence.y - ay;
    const cDist = Math.sqrt(cDx*cDx + cDy*cDy) + 0.01;
    const cForce = Math.max(0, crr.cohValue) * 0.8;
    fx += (cDx / cDist) * cForce;
    fy += (cDy / cDist) * cForce;
    
    // Regeneration left attractor
    const lDx = attractors.regenLeft.x - ax;
    const lDy = attractors.regenLeft.y - ay;
    const lDist = Math.sqrt(lDx*lDx + lDy*lDy) + 0.01;
    const lForce = Math.max(0, crr.regenLeft) * 0.6;
    fx += (lDx / lDist) * lForce;
    fy += (lDy / lDist) * lForce;
    
    // Regeneration right attractor
    const rDx = attractors.regenRight.x - ax;
    const rDy = attractors.regenRight.y - ay;
    const rDist = Math.sqrt(rDx*rDx + rDy*rDy) + 0.01;
    const rForce = Math.max(0, crr.regenRight) * 0.6;
    fx += (rDx / rDist) * rForce;
    fy += (rDy / rDist) * rForce;
    
    // Normalize and scale by 1/omega (lower omega = more decisive movement)
    const fMag = Math.sqrt(fx*fx + fy*fy) + 0.001;
    const scale = Math.min(fMag, 1) * (1 / (phase.omega + 0.2)) * 0.0008;
    
    return { 
        fx: (fx / fMag) * scale, 
        fy: (fy / fMag) * scale,
        cohValue: crr.cohValue,
        regenLeft: crr.regenLeft,
        regenRight: crr.regenRight
    };
}

function updateInsight() {
    const crr = calcCRR();
    let text = '';
    
    if (phase.coherence < 0.3) {
        text = 'Low coherence ‚Üí agent seeks information first (coherence attractor dominates).';
    } else if (phase.coherence > 0.7) {
        text = 'High coherence ‚Üí agent knows reward location, regenerates directly (memory-weighted preference dominates).';
    } else if (phase.cohWeight < 0.3) {
        text = 'Low coherence weight ‚Üí agent ignores information, gambles on reward.';
    } else if (phase.prefWeight < 0.3) {
        text = 'Low preference weight ‚Üí agent wanders, not driven by regeneration toward reward.';
    } else {
        text = 'Balanced weights ‚Üí agent integrates coherence-building and memory-weighted preference.';
    }
    
    $('phaseInsight').textContent = text;
}

function resizePhaseCanvas() {
    if (!phaseCanvas) return;
    const wrap = phaseCanvas.parentElement;
    phaseCanvas.width = wrap.clientWidth;
    phaseCanvas.height = wrap.clientHeight;
    phaseCtx = phaseCanvas.getContext('2d');
}

function drawPhaseSpace() {
    if (!phaseCtx) return;
    const ctx = phaseCtx;
    const w = phaseCanvas.width;
    const h = phaseCanvas.height;
    
    // Background
    ctx.fillStyle = '#050a12';
    ctx.fillRect(0, 0, w, h);
    
    // Grid
    ctx.strokeStyle = 'rgba(100, 255, 180, 0.04)';
    ctx.lineWidth = 1;
    for (let i = 0; i < w; i += 40) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, h); ctx.stroke(); }
    for (let i = 0; i < h; i += 40) { ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(w, i); ctx.stroke(); }
    
    const forces = getForces();
    
    // Draw flow field
    ctx.strokeStyle = 'rgba(100, 255, 180, 0.08)';
    ctx.lineWidth = 1;
    for (let gx = 0.1; gx < 1; gx += 0.08) {
        for (let gy = 0.15; gy < 0.95; gy += 0.08) {
            const px = gx * w;
            const py = gy * h;
            
            // Temporarily move agent to calculate local force
            const oldX = phase.agent.x, oldY = phase.agent.y;
            phase.agent.x = gx; phase.agent.y = gy;
            const localF = getForces();
            phase.agent.x = oldX; phase.agent.y = oldY;
            
            const fLen = 15;
            const fMag = Math.sqrt(localF.fx*localF.fx + localF.fy*localF.fy) + 0.0001;
            const fx = (localF.fx / fMag) * fLen;
            const fy = (localF.fy / fMag) * fLen;
            
            ctx.beginPath();
            ctx.moveTo(px, py);
            ctx.lineTo(px + fx * 500, py + fy * 500);
            ctx.stroke();
        }
    }
    
    // Draw attractors
    const drawAttractor = (att, strength, isCoherence) => {
        const px = att.x * w;
        const py = att.y * h;
        const baseR = 25;
        const clampedStrength = Math.max(0, strength);
        const r = baseR + clampedStrength * 30;
        
        // Glow using rgba colors
        const grad = ctx.createRadialGradient(px, py, 0, px, py, r * 1.5);
        grad.addColorStop(0, att.rgba + '0.25)');
        grad.addColorStop(0.5, att.rgba + '0.08)');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(px, py, r * 1.5, 0, Math.PI * 2);
        ctx.fill();
        
        // Core - ensure radius never goes negative
        const coreRadius = Math.max(4, 8 + clampedStrength * 12);
        ctx.fillStyle = att.color;
        ctx.shadowColor = att.color;
        ctx.shadowBlur = Math.max(5, 15 + clampedStrength * 10);
        ctx.beginPath();
        ctx.arc(px, py, coreRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Label
        ctx.fillStyle = '#fff';
        ctx.font = '10px JetBrains Mono';
        ctx.textAlign = 'center';
        ctx.fillText(att.label, px, py + r + 18);
        
        // Strength value
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.font = '9px JetBrains Mono';
        ctx.fillText(strength.toFixed(2), px, py + r + 30);
    };
    
    drawAttractor(attractors.coherence, forces.cohValue, true);
    drawAttractor(attractors.regenLeft, forces.regenLeft, false);
    drawAttractor(attractors.regenRight, forces.regenRight, false);
    
    // Draw agent trail
    if (phase.agent.trail.length > 1) {
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(phase.agent.trail[0].x * w, phase.agent.trail[0].y * h);
        for (let i = 1; i < phase.agent.trail.length; i++) {
            ctx.lineTo(phase.agent.trail[i].x * w, phase.agent.trail[i].y * h);
        }
        ctx.stroke();
    }
    
    // Draw agent
    const ax = phase.agent.x * w;
    const ay = phase.agent.y * h;
    
    // Agent glow
    const agentGrad = ctx.createRadialGradient(ax, ay, 0, ax, ay, 30);
    agentGrad.addColorStop(0, 'rgba(255,255,255,0.6)');
    agentGrad.addColorStop(0.5, 'rgba(255,255,255,0.1)');
    agentGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = agentGrad;
    ctx.beginPath();
    ctx.arc(ax, ay, 30, 0, Math.PI * 2);
    ctx.fill();
    
    // Agent core
    ctx.fillStyle = '#fff';
    ctx.shadowColor = '#fff';
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(ax, ay, 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    
    // Direction arrow
    if (Math.abs(phase.agent.vx) + Math.abs(phase.agent.vy) > 0.0001) {
        const vMag = Math.sqrt(phase.agent.vx**2 + phase.agent.vy**2);
        const vx = phase.agent.vx / vMag;
        const vy = phase.agent.vy / vMag;
        ctx.strokeStyle = 'rgba(255,255,255,0.6)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(ax + vx * 25, ay + vy * 25);
        ctx.stroke();
    }
    
    // Update readouts
    $('readoutE').style.width = Math.min(100, Math.max(0, forces.cohValue) * 50) + '%';
    $('readoutP').style.width = Math.min(100, Math.max(0, forces.regenLeft + 1) * 50) + '%';
    $('readoutG').style.width = Math.min(100, Math.max(0, forces.cohValue + forces.regenLeft + 1) * 35) + '%';
    $('readoutEVal').textContent = forces.cohValue.toFixed(2);
    $('readoutPVal').textContent = forces.regenLeft.toFixed(2);
    $('readoutGVal').textContent = (forces.cohValue + forces.regenLeft).toFixed(2);
}

function updatePhaseAgent() {
    const forces = getForces();
    
    // Add some noise based on omega (higher omega = more noise/exploration)
    const noise = phase.omega * 0.0003;
    
    phase.agent.vx += forces.fx + (Math.random() - 0.5) * noise;
    phase.agent.vy += forces.fy + (Math.random() - 0.5) * noise;
    
    // Damping
    phase.agent.vx *= 0.96;
    phase.agent.vy *= 0.96;
    
    // Update position
    phase.agent.x += phase.agent.vx;
    phase.agent.y += phase.agent.vy;
    
    // Bounds
    phase.agent.x = Math.max(0.05, Math.min(0.95, phase.agent.x));
    phase.agent.y = Math.max(0.1, Math.min(0.95, phase.agent.y));
    
    // Trail
    phase.agent.trail.push({ x: phase.agent.x, y: phase.agent.y });
    if (phase.agent.trail.length > 100) phase.agent.trail.shift();
}

function phaseLoop() {
    phase.time++;
    if (document.querySelector('#tab2.active')) {
        updatePhaseAgent();
        drawPhaseSpace();
    }
    requestAnimationFrame(phaseLoop);
}

// Slider handlers for phase space
$('phaseUnc').oninput = e => {
    phase.coherence = parseFloat(e.target.value);
    $('phaseUncVal').textContent = Math.round(phase.coherence * 100) + '%';
    updateInsight();
};

$('phaseEpi').oninput = e => {
    phase.cohWeight = parseFloat(e.target.value);
    $('phaseEpiVal').textContent = phase.cohWeight.toFixed(1);
    updateInsight();
};

$('phasePrag').oninput = e => {
    phase.prefWeight = parseFloat(e.target.value);
    $('phasePragVal').textContent = phase.prefWeight.toFixed(1);
    updateInsight();
};

$('phasePrec').oninput = e => {
    phase.omega = parseFloat(e.target.value);
    $('phasePrecVal').textContent = 'Œ© = ' + phase.omega.toFixed(1);
};

$('phaseReset').onclick = () => {
    phase.agent = { x: 0.5, y: 0.85, vx: 0, vy: 0, trail: [] };
};

// ============================================================================
// INIT
// ============================================================================
window.addEventListener('resize', () => {
    render.resize();
    resizePhaseCanvas();
});

goToStep(0);
setTimeout(resizePhaseCanvas, 100);
updateInsight();
requestAnimationFrame(loop);
requestAnimationFrame(phaseLoop);
</script>
</body>
</html>
